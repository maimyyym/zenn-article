---
title: "【ElasticSearch】フラットなマッピングのネストドキュメントをtermクエリで検索する"
emoji: "🔍"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ElasticSearch"]
published: false
publication_name: "fusic"
---
ElasticsearchやOpenSearchを使っていると、データ検索の際にクエリの違いによる挙動の変化に直面することがあります。
今回は、フラットなマッピング だが、ドキュメント自体はネストしている ケースで、term クエリと match クエリを用いた検索の違いに関する技術的な話を紹介します。

## 実現したいこと

## 課題

1. match クエリで検索できたが、term クエリではできなかった
match クエリを使用した場合、検索は期待通りに動作しました。しかし、同じフィールドに対して term クエリを使ったところ、検索結果が返ってこないという現象が発生しました。これに対して原因を調査した結果、フィールドのマッピングとアナライザーの問題が関与していました。

## まずは解決策のまとめ

## 必要な前提知識
 Elasticsearchのフィールドタイプ
Elasticsearchでは、ドキュメントのフィールド（プロパティ）にはいくつかの異なるタイプがあり、それによってデータのインデックス方法や検索方法が変わります。その中で、よく使われるのが text と keyword という2つのフィールドタイプです。

text フィールド
text フィールドは、全文検索を目的としています。データは トークン化 され、通常は形態素解析やステミングなどの処理を通じて検索可能な単語やフレーズに分解されます。例えば、「This is a test document」というフレーズが text フィールドにインデックスされる場合、これがトークン化されて、["this", "is", "a", "test", "document"] のように複数の単語に分解されます。

このようなフィールドでは、部分一致や関連度の高いドキュメントを検索するために match クエリがよく使用されます。match クエリでは、トークン化された単語やフレーズに基づいて検索されるため、完全一致ではなく、近似的な一致が行われます。

keyword フィールド
一方、keyword フィールドは、文字列全体をそのまま扱います。トークン化されることなく、フィールドにインデックスされたデータがそのまま保持され、完全一致の検索に使用されます。このフィールドは、識別子やタグ、ID、カテゴリなど、解析が不要なデータ に適しています。

例えば、「This is a test document」というフレーズが keyword フィールドにインデックスされる場合、フレーズ全体が1つのエンティティとして扱われ、部分一致は行われません。

2. text と keyword フィールドの違い
要約すると、text と keyword の主な違いは次の通りです：

text フィールド: トークン化され、部分一致や全文検索に適している。match クエリでよく使われる。
keyword フィールド: トークン化されず、データをそのまま保持し、完全一致に適している。term クエリで使用される。
3. Elasticsearch のデフォルト動作
Elasticsearch では、ドキュメントをインデックスに挿入すると、デフォルトで text と keyword の両方のフィールドが自動的に作成されます。これにより、同じフィールドに対しても、全文検索と完全一致検索の両方を柔軟に使い分けることが可能です。

例えば、次のようにフィールドが定義されます。

json
Copy code
{
  "properties": {
    "title": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword"
        }
      }
    }
  }
}
ここでは、title フィールドが text 型として定義されており、そのサブフィールドとして title.keyword が keyword 型として定義されています。これにより、title に対して全文検索を行うことも、title.keyword に対して完全一致の検索を行うことも可能になります。

4. term クエリと match クエリの使い分け
match クエリは、text フィールドのトークン化されたデータを検索するのに最適です。たとえば、文書の一部や単語の一部に基づいて検索結果を取得できます。
term クエリは、keyword フィールドに対して完全一致を行いたいときに使用します。このクエリは、トークン化されないフィールドに対して正確に一致するデータを取得します。

## 原因の詳細
2. 原因は「テキストフィールドのトークン化」
この現象の原因は、対象のフィールドがテキストフィールドであり、データがトークン化されていたためです。ElasticsearchやOpenSearchでは、match クエリは全文検索に適しており、テキストフィールドがトークン化された後でも検索が可能です。一方で、term クエリは完全一致を要求しますが、トークン化されたフィールドではこのような動作は期待できません。

## 解決策の詳細
3. 解決策：キーワード型を明示する
キーワード型を明示することで問題は解決しました。特定のフィールドに対して、keyword 型を指定することで、トークン化されたテキストとは異なり、文字列全体をそのまま検索対象にすることができます。以下はその例です：

json
Copy code
GET deck/_search
{
  "query": {
    "term": {
      "playlistOrder.id.keyword": "editorial-nwa-1000000005"
    }
  }
}
このクエリでは、playlistOrder.id.keyword に対して term クエリが使われており、トークン化されないキーワードフィールドを対象にすることで完全一致検索が可能になっています。

4. text と keyword フィールドのデフォルト設定
データを単にインデックスに挿入するだけでは、text と keyword の両方の型が自動的に設定され、全文検索（match）と完全一致検索（term）の両方で検索が可能になります。しかし、term クエリを使用する際は、keyword フィールドを指定することを忘れないようにする必要があります。
## 【余談】ネストされたマッピングの選択肢
ネストされた構造を持つデータに対しては、nested マッピングの使用も検討しました。しかし、nested マッピングは処理のコストやメモリの消費が増大するため、今回は避けました。nested マッピングはドキュメントのネスト構造を厳密に保持して検索するためのものですが、特定のケースではオーバーヘッドが高くなることがあります。

まとめ
term クエリで期待通りに検索結果を得るには、keyword 型を指定することが重要です。
match クエリはテキストフィールドのトークン化されたデータでも検索できますが、term クエリは完全一致が求められるため注意が必要です。
ネストされたドキュメントには、メモリやコスト面の考慮が必要であり、必ずしも nested マッピングが最適解ではありません。
これらのポイントを押さえることで、ElasticsearchやOpenSearchを活用した効率的なデータ検索を実現できるでしょう。
